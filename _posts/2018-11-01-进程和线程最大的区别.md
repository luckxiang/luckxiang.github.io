---
layout: post
title: 进程和线程最大的区别
date: 2018-11-01
categories: blog
tags: [技术]
description: 
---

最近又仔细思考了一下进程和线程的关系,我认为进程和线程最大的区别就是隔离,进程有独立的地址空间和资源,而线程没有.这样理解有什么用呢?当两个系统有隔离的需要,比如互不相关,或者一个系统的故障会导致另一个系统发生不可恢复的严重问题,又或者要把两个系统拆分到不同的主机上运行.我们就需要把系统设计成两个独立的进程,通过进程间通信来交换资源.如果没有隔离的需要,采用多线程的设计方式,则可以显著简化开发的复杂度并降低资源消耗,提高执行效率.像ecos这样的系统根本就没有进程,它的整个系统可以看做一个单进程的应用.基于该系统构建的应用工作得也非常好.由此可见,线程就可以解决并发的问题,进程可以看做线程的一个补充,用来处理程序间的隔离性问题.说到这里,不得不提一下协程,协程一般是一个实现在单线程里边的调度模型,适合用在IO密集型的应用中,它不能并行,但是可以提高调度效率(不需要内核调度).由于是单线程,也没有讨厌的同步问题.lua和go都支持了协程的概念,go语言的并发效果那么优秀不是没有道理的.如果想在linux下玩玩协程,glic已经实现了,参见ucontext.h.      
   
---  

2018年12月21日：      
最近又去研究了一下go的协程调度机制，我发现go的调度机制并不只是单线程那么简单，而是采用了所谓的M、P、G结构，允许多个调度线程并发调度每个协程单元，使用消息机制作为协程之间的通信手段。原理其实很简单，就是在每个线程下挂一个调度器，提高调度效率，但是这样又会引入线程的竞争问题，所以官方推出了channel机制作为标准解决方案。我看有的博客用锁来演示协程demo，其实是不合理的，不过恰恰是这个问题引起了我的注意：原来go的协程调度不是单线程的。如果让我设计，多线程的调度方案在高并发的需求下确实也是一个很合理的方案。有时间多研究一下go,哈哈哈...
